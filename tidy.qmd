---
title: "Tidy Data"
format: 
  html:
     code-fold: true
     code-summary: "Show the code"
number-sections: true
---

```{r}
#| include: false

set.seed(214)

```

*Tidy Data* is a consistent way to organise your data [@wickham_tidy_2014] [@JSSv105i07]. Getting your data into this format requires some initial work, but that effort pays off in the long term. Once you have tidy data you will spend *less* time wrangling data from one representation to another, allowing you to spend more time on the analytic questions at hand. Unfortunately, there is a rule of thumb; 80% of time doing data science is spent wrangling data; particularly the effort required in sorting and rearranging the data into the *tidy* and therefore usable format; illustrated below are ways to make this task less demanding. 

There are three interrelated rules which make a data set tidy see @fig-threerules:

-   Each variable must have its own column.
-   Each observation must have its own row.
-   Each value must have its own cell.

![Rules for Tidy Data](Images/TidyDataBats.PNG){#fig-threerules}

## Minimal Data Requirement

To undertake meaningful data analysis, it is recommended that data collected from bat activity surveys is wrangled into *tidy data* that has the following five variables (columns) as a minimum (as shown in @tbl-tidy):

-   Description
-   DateTime
-   Species
-   Latitude
-   Longitude

The rationale for these variables is as follows:

`Description` a column to help identify the observation for example a location, surveyor or survey number.

:::{.callout-tip}
# Always Use a Description

Although a description column is not absolutely necessary for a minimal data set. Description column(s) portraying the _location, survey number or surveyor_ gives both the data and the analysis context.

:::

`DateTime`: the date and time of the bat observation to BS ISO 8601:2004 i.e. `yyyymmdd hh:mm:ss`. The use of BS ISO 8601:2004 prevents confusion over the date format [^1] . Reference bat activity to the local time and specifying an *iana*[^2] time zone allows for daylight saving times to considered; the *iana* code for the UK is `Europe/London`.

[^1]: the standard is recommended by .gov.uk<https://www.gov.uk/government/publications/open-standards-for-government/date-times-and-time-stamps-standard>

[^2]: a full list of time zones can be found here <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>

`Species`: bat species names should follow the "binomial nomenclature" from the International Code of Zoological Nomenclature (ICZN)[^3] - e.g. *Barbastella barbastellus*, *Eptesicus serotinus*, etc... A column of local common names can always be added to the *tidy* data, i.e. in a separate column see [Meta Data](https://bat-survey-reporting.netlify.app/meta.html#common-bat-names). A compiled online database [_Bats of the World_](https://batnames.org/) provides taxonomic and geographic information on all Chiroptera [^4]. As of 10^th^ Mar 2023, __1462__ species are recognized. Sound analysis may not be able to distinguish calls to species level; in practice some calls may only be identified to genus or as acoustically similar, @tbl-UKbatNames suggests a naming convention.

[^3]: <https://www.iczn.org/the-code/the-international-code-of-zoological-nomenclature/the-code-online/>

[^4]: Simmons, N.B. and A.L. Cirranello. 2023. Bat Species of the World: A taxonomic and geographic database. Version 1.3. Accessed on 03/14/2023. 

`Longitude` and `Latitude`: World Geodetic System 1984[^5] (WGS84); as used by Google earth. A digital, numeric, format should be used. Any other spatial reference system can be used, as these can be stored as an extra column in the *tidy data*; an example of British National Grid co-ordinates (Easting/Northing) is provided in [Meta Data](https://bat-survey-reporting.netlify.app/meta.html#national-grid-coordinates). The prerequisite is that the reference system can be converted to WGS84; which is the case for most national or state co-ordinate systems. Using a global co-ordinate system such as WSG84 gives access to the many open-source application programming interfaces (API) available that assist with data analysis (e.g. assessing sunset and sunrise times or the adjustment to daylight saving).

[^5]: <https://en.wikipedia.org/wiki/World_Geodetic_System>


```{r}
#| warning: false
#| message: false
#| label: tbl-tidy
#| tbl-cap: "Tidy Bat data"

library(tidyverse)
library(iBats)
library(gt)

statics %>% # statics is a tidy data set from the iBats package
  select(Description, DateTime, Species, Latitude, Longitude) %>%
  sample_n(10) %>%
  arrange(DateTime) %>%
  # Table made with gt()
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>%
  # Make bat scientific name italic
  tab_style(
    style = list(
      cell_text(style = "italic")
    ),
    locations = cells_body(
      columns = c(Species)
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```


## Making Bat Data *Tidy*

Results of bat sound analysis can be untidy:

-   two or more species in one cell (see @tbl-untidy1);
-   count of bats (@tbl-untidy2); 
-   two of more columns with species of same date and time (@tbl-untidy3);
-   code names for species rather than the binomial nomenclature (@tbl-tidied1); and,
-   Longitude and Latitude columns with missing values (@tbl-missinglonlat)

While the bat survey results shown in @tbl-tidy is an example of a *tidy* data set; the data shown in @tbl-untidy1, @tbl-untidy2, @tbl-untidy3, @tbl-tidied1 and, @tbl-missinglonlat are *untidy* and would need to be made tidy to undertake analysis.

Data preparation is not just a first step but must be repeated many times over during analysis; as new problems come to light, or new data is collected. Making bat data into a *tidy format*, involves cleaning data: parsing dates and numbers, identifying missing values, correcting character encoding, matching similar but not identical values (such as those created by typos); it is an essential step, takes time to do and makes subsequent steps in the analysis much easier.

### Too Many Species in a Cell

```{r}
#| warning: false
#| message: false
#| label: tbl-untidy1
#| tbl-cap: "Untidy Bat Data Too Many Species in a Cell"

library(gt)
library(iBats)

# Table made with gt()
untidy1 %>%
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```

Too many species in a cell, as in @tbl-untidy1, can be made tidy by expanding the data so each species observed is in it's own row, using the function `tidyr::separate_rows(Species)`; as shown below in @tbl-tidied1. Note that this data has _untidy_ bat names; these are corrected in @sec-scinames. The `untidy1` data is example untidy data available from the *iBats* package.

```{r}
#| warning: false
#| message: false
#| code-fold: show
#| label: tbl-tidied1
#| tbl-cap: "Tidied Bat Data from Too Many Species in a Cell"

### Libraries Used
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/
library(gt) # Makes table

# Install devtools if not installed
# devtools is used to install the iBats package from GitHub
if (!require(devtools)) {
  install.packages("devtools")
}

# If iBats is not installed load from Github
if (!require(iBats)) {
  devtools::install_github("Nattereri/iBats")
}
library(iBats)

untidy1 %>%
  tidyr::separate_rows(Species) %>%
  # Table made with gt()
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```

### A Column of Bat Counts

```{r}
#| warning: false
#| message: false
#| label: tbl-untidy2
#| tbl-cap: "Untidy Bat Data a Column Giving the Number of Bat Passes"

library(gt)
library(iBats)

# Table made with gt()
untidy2 %>%
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )


```

A count of species, as in @tbl-untidy2, can be made tidy by un-counting the data so each species observed is in it's own row, using the function `tidyr::uncount(Number)`; as shown below in @tbl-tidied2. The `untidy2` data is example untidy data available from the *iBats* package.

```{r}
#| code-fold: show
#| label: tbl-tidied2
#| tbl-cap: "Tidied Bat Data with the Column Bats Un-counted"

### Libraries Used
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/
library(gt) # Makes table

# Install devtools if not installed
# devtools is used to install the iBats package from GitHub
if (!require(devtools)) {
  install.packages("devtools")
}

# If iBats is not installed load from Github
if (!require(iBats)) {
  devtools::install_github("Nattereri/iBats")
}
library(iBats)

untidy2 %>%
  tidyr::uncount(Number) %>%
  # Table made with gt()
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```

### Two or More Columns of Bat Species

```{r}
#| warning: false
#| message: false
#| label: tbl-untidy3
#| tbl-cap: "Two or More Columns of Bat Species"

library(gt)
library(iBats)

# Table made with gt()
untidy3 %>%
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )
```

Several columns of species, as in @tbl-untidy3, can be made tidy by making separate data.frames and binding them together so each species observed is in it's own row; as shown below in @tbl-tidied3. The `untidy3` data is example untidy data available from the *iBats* package.

```{r}
#| code-fold: show
#| warning: false
#| message: false
#| label: tbl-tidied3
#| tbl-cap: "Tidied Bat Data with Two or More Columns put into One"

### Libraries Used
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/

# Install devtools if not installed
# devtools is used to install the iBats package from GitHub
if (!require(devtools)) {
  install.packages("devtools")
}

# If iBats is not installed load from Github
if (!require(iBats)) {
  devtools::install_github("Nattereri/iBats")
}
library(iBats)

# Select Species column and remove (Species2nd & Species3rd)
data1 <- untidy3 %>%
  select(-Species2nd, -Species3rd)

# Select Species2nd column and remove (Species & Species3rd)
data2 <- untidy3 %>%
  select(-Species, -Species3rd) %>%
  filter(Species2nd != "") %>% # Remove blank rows
  rename(Species = Species2nd) # Rename column

# Select Species3rd column and remove (Species & Species2nd)
data3 <- untidy3 %>%
  select(-Species, -Species2nd) %>%
  filter(Species3rd != "") %>% # Remove blank rows
  rename(Species = Species3rd) # Rename column

# Add the datasets together into one
dplyr::bind_rows(data1, data2, data3) %>%
  # Table made with gt()
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```


### Convert Bat Names to Scientific {#sec-scinames}

@tbl-tidied1 is still *untidy* because the bat species are represented as codes and not in a binomial nomenclature(scientific name). The `iBats::make_scientific()` function can take a named vector of codes and the scientific name; such as the `BatScientific` vector below. The case of the bat name codes are ignored; they are all converted to lower case.

```{r}
#| code-fold: show

BatScientific <- c("nyclei" = "Nyctalus leisleri",
                   "nycnoc" = "Nyctalus noctula",
                   "pippip" = "Pipistrellus pipistrellus",
                   "pipnat" = "Pipistrellus nathusii",
                   "pippyg" = "Pipistrellus pygmaeus",
                   "45 pip" = "Pipistrellus pipistrellus",
                   "55 pip" = "Pipistrellus pygmaeus",
                   "bleb" = "Plecotus auritus",
                   # If already a scientific name keep it
                   "myotis daubentonii" = "Myotis daubentonii") 

```

The `BatScientific` vector is then used to covert the survey vector of bat names (the Species column in @tbl-tidied1) so they are all scientific; using the `iBats::make_scientific()` function. The `BatScientific` can be expanded to cover many names and codes, if there are duplicate names or codes a conversion will not take place for that name or code. The tidied data with scientific species names is shown in @tbl-tidied4

```{r}
#| code-fold: show
#| warning: false
#| message: false


### Libraries Used 
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/

# Install devtools if not installed 
# devtools is used to install the iBats package from GitHub
if(!require(devtools)){
  install.packages("devtools")
}

# If iBats is not installed load from Github
if(!require(iBats)){
  devtools::install_github("Nattereri/iBats")
}
library(iBats)

# Remove too many species in a cell
tidied1 <- untidy1 %>%
  tidyr::separate_rows(Species)

tidied1$Species <- iBats::make_scientific(BatScientific, tidied1$Species)

```

```{r}
#| label: tbl-tidied4
#| tbl-cap: "Tidied Data with Scientific Names"

library(gt)
# Table made with gt()
tidied1 %>% 
  gt() %>% 
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
      ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # Make bat scientific name italic
  tab_style(
    style = list(
      cell_text(style = "italic")
      ),
    locations = cells_body(
      columns = c(Species)
  )) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```

### Missing Latitude and Longitude Values

The `BatExplorer` data in the *iBats* package (see @tbl-missinglonlat), was recorded on an evening transect bat detector survey. The data has missing longitude and latitude values, shown as `NA` and is not uncommon when the Global Positioning System (GPS) is trying to calculate its position beneath trees or in a steep valley.

```{r}
#| label: tbl-missinglonlat
#| tbl-cap: "Missing Longitude and Latitude Values (NA)"

### Libraries Used 
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/
library(iBats)
library(gt)

# BatExplorer csv file is from the iBats package
BatExplorer %>% 
  head(n=15L)  %>% 
  select(DateTime = Timestamp, 
         Species = `Species Text`, 
         Latitude = `Latitude [WGS84]`,
         Longitude = `Longitude [WGS84]`) %>% 
  # Table made with gt()
  gt() %>% 
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
      ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # Make bat scientific name italic
  tab_style(
    style = list(
      cell_text(style = "italic")
      ),
    locations = cells_body(
      columns = c(Species)
  )) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )

```

The longitude and latitude gives a position of the bat observation and is also used to determine sunset and sunrise; and if the values are not completed then these observations would be excluded from the analysis. A simple estimate of the missing latitude and longitude can be made by arranging the data in date/time order and using the function:  

`tidyr::fill(c(Latitude, Longitude), .direction = "downup")` 

This fills the missing values from the nearest complete values; first down and then up.  The filled data is shown in @tbl-filledlonlat.

:::{.callout-warning}
## Warning

Latitude and longitude is required in every row for the sun times can be calculated.
:::


```{r}
#| code-fold: show
#| warning: false
#| message: false
#| eval: false


### Libraries Used
library(tidyverse) # Data Science packages - see https://www.tidyverse.org/

# Install devtools if not installed
# devtools is used to install the iBats package from GitHub
if (!require(devtools)) {
  install.packages("devtools")
}

# If iBats is not installed load from Github
if (!require(iBats)) {
  devtools::install_github("Nattereri/iBats")
}
library(iBats)

# BatExplorer csv file is from the iBats package
BatExplorer %>%
  head(n = 15L) %>%
  select(
    DateTime = Timestamp,
    Species = `Species Text`,
    Latitude = `Latitude [WGS84]`,
    Longitude = `Longitude [WGS84]`
  ) %>%
  arrange(DateTime) %>% 
  tidyr::fill(c(Latitude, Longitude), .direction = "downup")

```

```{r}
#| label: tbl-filledlonlat
#| tbl-cap: "Filled Longitude and Latitude Values"

# BatExplorer csv file is from the iBats package
BatExplorer %>% 
  head(n=15L)  %>% 
  select(DateTime = Timestamp, 
         Species = `Species Text`, 
         Latitude = `Latitude [WGS84]`,
         Longitude = `Longitude [WGS84]`) %>% 
  fill(Latitude, .direction = "downup") %>%
    fill(Longitude, .direction = "downup") %>% 
  gt() %>% 
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
      ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # Make bat scientific name italic
  tab_style(
    style = list(
      cell_text(style = "italic")
      ),
    locations = cells_body(
      columns = c(Species)
  )) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) %>% 
  cols_align(
    align = "left",
    columns = DateTime
  )



```


{{< include ../Common/bats/soundanalysisoutput.qmd >}}

## Sound Analysis and Naming Bats

Sound analysis may not be able to distinguish calls to species level; in practice some calls may only be identified to genus or as acoustically similar; @tbl-UKbatNames suggests a naming convention for UK bat species[^6]

[^6]: Adapted from [EcoBat's](http://www.ecobat.org.uk/) naming convention.

```{r}
#| label: tbl-UKbatNames
#| tbl-cap: "Sound Analysis and Naming Bats"

# UK_bat_names is from the iBats package
UK_bat_names %>% 
  select(-Common) %>% 
  mutate_if(is.character, ~replace_na(.,"")) %>% 
  rename(Species = Binomial, `Acoustic Group 1` = AcousticallySimilar1, `Acoustic Group 2` = AcousticallySimilar2) %>% 
  gt() %>% 
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
      ),
    locations = cells_column_labels(
      columns = c(everything())
    )
  ) %>% 
  # Make bat scientific name italic
  tab_style(
    style = list(
      cell_text(style = "italic")
      ),
    locations = cells_body(
      columns = c(everything())
  )) %>% 
  # reduce cell space
  tab_options(data_row.padding = px(2)) 



```


## Data Validation

```{r}
#| include: false

library(tidyverse)
library(iBats)
library(validate)
library(flextable)

```



Making tidy data takes time and unintentional mistakes are easily made, its good practice to validate  the data before it is used for reporting.  The R package `validation` allows rules to be defined to check the data meets expectations, providing confidence for the data when used in analysis. The code below sets out the rules checking the  `iBats::statics` data:


```{r}

SpeciesList <- c(
  "Barbastella barbastellus",
  "Myotis alcathoe",
  "Myotis bechsteinii",
  "Myotis brandtii",
  "Myotis mystacinus",
  "Myotis nattereri",
  "Myotis daubentonii",
  "Myotis spp.",
  "Plecotus auritus",
  "Plecotus spp.",
  "Plecotus austriacus",
  "Pipistrellus pipistrellus",
  "Pipistrellus nathusii",
  "Pipistrellus pygmaeus",
  "Pipistrellus spp.",
  "Rhinolophus ferrumequinum",
  "Rhinolophus hipposideros",
  "Nyctalus noctula",
  "Nyctalus leisleri",
  "Nyctalus spp.",
  "Eptesicus serotinus"
)

rules <- validator(
  # Check column types are corrects class
  Description.col.type = is.character(Description),
  DateTime.col.type = is.POSIXct(DateTime),
  Species.col.type = is.character(Species),
  Lat.col.type = is.numeric(Latitude),
  Lon.col.type = is.numeric(Longitude),
 
  # Ensure that all DateTime values are the length for yyyy-mm-dd hh:mm:ss n = 19
  DateTime.len = field_length(DateTime, n = 19),
  
  # Ensure that there are no duplications of species pass and date/time
  unique.bat.pass =is_unique(Species, DateTime),
  
  # location_vars := var_group(Latitude, Longitude),
  # lat.missing = !is.na(location_vars),
  
  # Ensure that Latitude and Longitude doesn't have any missing values
  lat.missing = !is.na(Latitude),
  lon.missing = !is.na(Longitude),
  
  # Ensure latitude and longitude are valid locations
  lat.within.range = in_range(Latitude, min=-90, max=90),
  lon.within.range = in_range(Longitude, min=-180, max=180),
  
  #Check species is valid name
  species.names = Species %in% SpeciesList
)



```

The rules can then be applied to a data set with the `confront` function; below the`confront` function applies these rules to the `statics` data; an output summary is shown in @tbl-confront. Rules can be constructed and applied to any data set used to make bat reports; the rules can then be re-applied when the data is modified; for example when new data is appended. 

```{r}
#| label: tbl-confront
#| tbl-cap: "Validation Summary"

x <- confront(statics, rules) 

summary(x) %>% 
  flextable() %>% 
  autofit() %>% 
  fontsize(part = "body", size = 10) %>%
    bold(part = "header") %>% 
    bg(bg = "black", part = "header") %>% 
    color(color = "white", part = "header") %>% 
    align(j = 1, align = "center", part = "header") 
```


In @tbl-confront the `is_unique(Species, DateTime)` rule shows 6 fails in the `statics` data; to view these _fails_ the `violating` function is used. @tbl-violating lists the _fails_ in the `statics` data allowing the discrepancies in the data to be judged; although here the date/time and species is a duplication the _Description's_ are different (and therefore not a duplication). A better rule too use would be `validator(is_unique(Description, Species, DateTime))`.  


```{r}
#| label: tbl-violating
#| tbl-cap: "Failed rows in the statics data"

rule <- validator(is_unique(Species, DateTime))
out <- confront(statics, rule)

violating(statics, out) %>% 
  flextable() %>% 
  autofit() %>% 
    bold(part = "header") %>% 
    bg(bg = "black", part = "header") %>% 
    color(color = "white", part = "header") %>% 
    align(j = 1, align = "center", part = "header") 



```


